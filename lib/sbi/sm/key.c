#include "sm/key.h"
#include "sm/enclave.h"
#include "sm/hkdf/sha.h"
#include "sbi/sbi_console.h"

// FIXME: the root key must be generated by hardware
static char storage_key[KEY_SIZE_BYTES] = {
        0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,
        0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08,
        0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,
        0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08
    };

static char enclave_key[KEY_SIZE_BYTES] = {
        0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,
        0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08,
        0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,
        0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08
    };

int m_derive_key(int key_type, unsigned char *enclave_hash, int key_size, char *okey)
{
    int ret = 0;
    
    // FIXME: derive key with the enclave id
    switch (key_type)
    {
        case ENCLAVE_KEY:
            hkdf(SHA256, enclave_hash, HASH_SIZE, (unsigned char *)enclave_key, KEY_SIZE_BYTES,
                    NULL, 0, (uint8_t *)okey, key_size);
            break;
        case STORAGE_KEY:
            hkdf(SHA256, enclave_hash, HASH_SIZE, (unsigned char *)storage_key, KEY_SIZE_BYTES,
                    NULL, 0, (uint8_t *)okey, key_size);
            break;
        default:
            sbi_bug("M MODE: m_derive_key: the key type is not supported\n");
            break;
    }

    return ret;
}

// TODO: cryptographic seed should be generated by trusted hardware
// Just for test!
int seed = 12345;

/**
 * \brief Pseudorandom algorithm to get the random value.
 * 
 * \param buff Receiving buff for the random value
 * \param size The size of random value 
 */
uintptr_t platform_getrand(char* buff, uintptr_t size) {
  int m = 1 << 20, a = 9, b = 7; // a = 4p + 1, b = 2q + 1
  int i, need_rand_int = 0;
  for (i = 0; i < size; i++)
  {
    if (!need_rand_int)
    {
      seed = ( a * seed + b ) % m;
      need_rand_int = sizeof(int) / sizeof(char);
    }

    buff[i] = ((char *)&seed)[need_rand_int - 1];
    need_rand_int--;
  }
  return size;
}